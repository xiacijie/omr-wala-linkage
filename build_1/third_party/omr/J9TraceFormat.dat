5.1
j9hook.0 0 1 1 N Trc_Hook_Dispatch_Exceed_Threshold_Event "  Warning - The hookFunction, which is registered in %s, is taking too long(%zu milliseconds)."
j9utilcore.0 1 1 1 N Trc_Utilcore_decodeUTF8CharN_EmbdeddedNul "* decodeUTF8CharN - embedded NUL character found"
j9utilcore.1 1 1 1 N Trc_Utilcore_decodeUTF8CharN_Truncated "* decodeUTF8CharN - not enough data left"
j9utilcore.2 1 1 1 N Trc_Utilcore_decodeUTF8CharN_Invalid2ByteEncoding "* decodeUTF8CharN - invalid 2 byte encoding (0x%x)"
j9utilcore.3 1 1 1 N Trc_Utilcore_decodeUTF8CharN_Invalid3ByteEncoding "* decodeUTF8CharN - invalid 3 byte encoding (0x%x)"
j9utilcore.4 1 1 1 N Trc_Utilcore_decodeUTF8CharN_EncodingTooLarge "* decodeUTF8CharN - invalid encoding (0x%x)"
avl.0 2 1 3 N Trc_AVL_findRightMostLeaf_Entry " >findRightMostLeaf(tree=%p, walkSRPPtr=%p, heightChange=%p)"
avl.1 4 1 3 N Trc_AVL_findRightMostLeaf_NotFound " <findRightMostLeaf -- walk is NULL"
avl.2 4 1 3 N Trc_AVL_findRightMostLeaf_Exit " <findRightMostLeaf -- found %p"
avl.3 2 1 3 N Trc_AVL_rotate_Entry " >rotate(tree=%p, walk=%p, direction=%zi, heightChange=%p)"
avl.4 4 1 3 N Trc_AVL_rotate_Exit " <rotate -- heavyNode=%p"
avl.5 2 1 3 N Trc_AVL_doubleRotate_Entry " >doubleRotate(tree=%p, walk=%p, direction=%zi, heightChange=%p)"
avl.6 4 1 3 N Trc_AVL_doubleRotate_Exit " <doubleRotate -- newRootNode=%p"
avl.7 2 1 3 N Trc_AVL_rebalance_Entry " >rebalance(tree=%p, walkPtr=%p, walkSRPPtr=%p, direction=%zi, heightChange=%p)"
avl.8 4 1 3 N Trc_AVL_rebalance_Exit " <rebalance - heightChange=%zi"
avl.9 2 1 3 N Trc_AVL_insertNode_Entry " >insertNode(tree=%p, walkPtr=%p, walkSRPPtr=%p, node=%p, heightChange=%p)"
avl.10 4 1 3 N Trc_AVL_insertNode_Trivial " <insertNode -- inserted trivially: %p"
avl.11 4 1 3 N Trc_AVL_insertNode_Exists " <insertNode -- node already exists: %p"
avl.12 4 1 3 N Trc_AVL_insertNode_Recursive " <insertNode -- inserted recursively: %p"
avl.13 2 1 3 N Trc_AVL_findNode_Entry " >findNode(tree=%p, walk=%p, search=%zu)"
avl.14 4 1 3 N Trc_AVL_findNode_Exit " <findNode -- result=%p"
avl.15 2 1 3 N Trc_AVL_deleteNode_Entry " >deleteNode(tree=%p, walkPtr=%p, walkSRPPtr=%p, node=%p, heightChange=%p)"
avl.16 4 1 3 N Trc_AVL_deleteNode_NotInTree " <deleteNode -- node is not in this tree"
avl.17 4 1 3 N Trc_AVL_deleteNode_Removed " <deleteNode -- node removed: %p"
avl.18 4 1 3 N Trc_AVL_deleteNode_Recursive " <deleteNode -- deleted recursively: %p"
avl.19 12 1 1 N Assert_AVL_true "* ** ASSERTION FAILED ** at %s:%d: %s"
avl.20 12 1 1 N Assert_AVL_false "* ** ASSERTION FAILED ** at %s:%d: %s"
hashtable.0 12 1 1 N Assert_hashTable_true "* ** ASSERTION FAILED ** at %s:%d: %s"
hashtable.1 12 1 1 N Assert_hashTable_false "* ** ASSERTION FAILED ** at %s:%d: %s"
hashtable.2 12 1 1 N Assert_hashTable_unreachable "* ** ASSERTION FAILED ** at %s:%d: %s"
hashtable.3 2 1 1 N Trc_hashTable_listToTree_Entry " >HashTable start converting list to tree: tableName=%s, tableAddress=%p, head=%p, listLength=%zu"
hashtable.4 4 1 1 N Trc_hashTable_listToTree_Exit " <HashTable finish converting list to tree: rc=%zu tree=%p "
pool.0 2 1 3 N Trc_pool_new_Entry " >pool_new(structSize=%u, minNumberElements=%u elementAlignment=%u poolFlags=0x%zx, memAlloc=%p, memFree=%p, userData=%p)"
pool.1 4 1 1 N Trc_pool_new_TooLargeExit " <pool_new too large (puddleAllocSize=%u)"
pool.2 4 1 3 N Trc_pool_new_Exit " <pool_new(result=%p)"
pool.3 2 1 3 N Trc_pool_kill_Entry " >pool_kill(%p)"
pool.4 4 1 3 N Trc_pool_kill_Exit " <pool_kill"
pool.5 2 1 4 N Trc_pool_newElement_Entry " >pool_newElement(pool=%p)"
pool.6 4 1 4 N Trc_pool_newElement_Exit " <pool_newElement(result=%p)"
pool.7 2 1 4 N Trc_pool_removeElement_Entry " >pool_removeElement(pool=%p, anElement=%p)"
pool.8 1 1 1 N Trc_pool_removeElement_NotFound "* pool_removeElement -- %p not found in any puddle of %p"
pool.9 4 1 4 N Trc_pool_removeElement_Exit " <pool_removeElement"
pool.10 2 1 4 N Trc_pool_do_Entry " >pool_do(aPool=%p, aFunction=%p, userData=%p)"
pool.11 4 1 4 N Trc_pool_do_Exit " <pool_do"
pool.12 2 1 4 N Trc_pool_numElements_Entry " >pool_numElements(aPool=%p)"
pool.13 4 1 4 N Trc_pool_numElements_Exit " <pool_numElements(result=%zu)"
pool.14 2 1 4 N Trc_pool_startDo_Entry " >pool_startDo(aPool=%p, state=%p)"
pool.15 1 1 1 N Trc_pool_startDo_NULLPool "* pool_startDo - pool is NULL"
pool.16 4 1 4 N Trc_pool_startDo_Empty " <pool_startDo - no elements"
pool.17 4 1 4 N Trc_pool_startDo_Exit " <pool_startDo - first element is %p"
pool.18 2 1 4 N Trc_pool_nextDo_Entry " >pool_nextDo(state=%p)"
pool.19 4 1 4 N Trc_pool_nextDo_NextPuddle " <pool_nextDo - advance to next puddle"
pool.20 4 1 4 N Trc_pool_nextDo_Finished " <pool_nextDo - no more elements"
pool.21 4 1 4 N Trc_pool_nextDo_Exit " <pool_nextDo - result=%p"
pool.22 2 1 3 N Trc_pool_sortFree_Entry " >pool_sortFree(%p)"
pool.23 1 1 1 N Trc_pool_sortFree_Conflict "* pool_sortFree - conflict at element %p in pool %p with 0x%zx"
pool.24 4 1 3 N Trc_pool_sortFree_Exit " <pool_sortFree"
pool.25 2 1 3 N Trc_pool_clear_Entry " >pool_clear(%p)"
pool.26 4 1 3 N Trc_pool_clear_Exit " <pool_clear"
pool.27 2 1 3 N Trc_pool_ensureCapacity_Entry " >pool_ensureCapacity(aPool=%p, newCapacity=%zu)"
pool.28 1 1 1 N Trc_pool_ensureCapacity_OutOfMemory "* pool_ensureCapacity - failed to allocate memory to grow capacity to %zu"
pool.29 4 1 3 N Trc_pool_ensureCapacity_Exit " <pool_ensureCapacity(result=%zu)"
pool.30 2 1 3 N Trc_pool_capacity_Entry " >pool_capacity(aPool=%p)"
pool.31 4 1 3 N Trc_pool_capacity_Exit " <pool_capacity(result=%zu)"
pool.32 2 1 3 N Trc_poolPuddle_new_Entry " >poolPuddle_new(%p)"
pool.33 4 1 3 N Trc_poolPuddle_new_Exit " <poolPuddle_new exiting with %p"
pool.34 2 1 3 N Trc_pool_newWithPuddleAlloc_Entry " >pool_newWithPuddleAlloc(%d, %d, %d, %x, %p, %p,	%p, %p, %p, %p)"
pool.35 4 1 3 N Trc_pool_newWithPuddleAlloc_TooLargeExit " <pool_newWithPuddleAlloc exit: puddle alloc size %lld too large"
pool.36 4 1 3 N Trc_pool_newWithPuddleAlloc_Exit " <pool_newWithPuddleAlloc exit with %p"
pool.37 2 1 3 N Trc_poolPuddle_startDo_Entry " >poolPuddle_startDo(aPool=%p, currentPuddle=%p, lastHandle=%p, followNextPointers=%d)"
pool.38 4 1 3 N Trc_poolPuddle_startDo_ExitNullPoolPuddleExit " <poolPuddle_startDo exiting because of NULL puddle"
pool.39 4 1 3 N Trc_poolPuddle_startDo_EmptyExit " <poolPuddle_startDo exiting because the puddle is empty"
pool.40 4 1 3 N Trc_poolPuddle_startDo_Exit " <poolPuddle_startDo exiting with %p"
pool.41 4 1 3 N Trc_pool_newElement_ExitNoop " <pool_newElement exiting as one or more parameters is NULL"
pool.42 4 1 3 N Trc_pool_removeElement_ExitNoop " <pool_removeElement exiting as one or more parameters is NULL"
pool.43 4 1 3 N Trc_pool_sortFree_ExitNoop " <pool_sortFree exiting as one or more parameters is NULL"
pool.44 4 1 3 N Trc_pool_includesElement_ExitNoop " <pool_includesElement exiting as one or more parameters is NULL"
pool.45 2 1 3 N Trc_pool_includesElement_Entry " >pool_includesElement(aPool=%p, anElement=%p)"
pool.46 4 1 3 N Trc_pool_includesElement_ExitFullPuddle " <pool_includesElement exiting with TRUE as puddle containing element is full"
pool.47 4 1 3 N Trc_pool_includesElement_ExitFoundFree " <pool_includesElement exiting with FALSE as element has been freed"
pool.48 4 1 3 N Trc_pool_includesElement_ExitSuccess " <pool_includesElement exiting with TRUE as element is currently allocated"
pool.49 4 1 3 N Trc_pool_includesElement_ExitOutOfScope " <pool_includesElement exiting with FALSE as element is not in scope of the pool"
pool.50 2 1 1 N Trc_pool_verify_Entry " >pool_verify(aPool=%p)"
pool.51 4 1 1 N Trc_pool_verify_ExitCorruptPuddle " <pool_verify failed pool %p corrupt puddle %p"
pool.52 4 1 1 N Trc_pool_verify_ExitNoActive " <pool_verify failed pool %p active puddle %p not found"
pool.53 4 1 1 N Trc_pool_verify_ExitSuccess " <pool_verify success pool %p numElements %d numPuddles %d"
pool.54 4 1 1 N Trc_pool_verify_ExitInvalidFirstElement " <pool_verify failed pool %p puddle %p invalid first element %p"
pool.55 4 1 1 N Trc_pool_verify_ExitFreeSlotInvalid " <pool_verify failed pool %p puddle %p first free slot invalid %p"
pool.56 0 1 1 N Trc_pool_newElement_FreeSlotInvalid "  pool_newElement pool %p puddle %p free slot in element %p invalid %p"
pool.57 2 1 3 N Trc_pool_killWithoutPuddles_Entry " >pool_killWithoutPuddles(%p)"
pool.58 4 1 3 N Trc_pool_killWithoutPuddles_Exit " <pool_killWithoutPuddles"
pool.59 4 1 1 N Trc_pool_verify_ExitNoPuddleList " <pool_verify pool %p has no puddle list"
pool.60 4 1 1 N Trc_pool_verify_ExitNoNextAvailablePuddle " <pool_verify failed pool %p next available puddle %p not found"
pool.61 4 1 1 N Trc_pool_verify_ExitNumElementsMismatch " <pool_verify failed pool %p element count mismatch found %d expected %d"
pool.62 4 1 1 N Trc_pool_new_ArgumentTooLargeExit " <pool_new too large (structSize=%zu, minNumberElements=%zu elementAlignment=%zu)"
pool.63 4 1 1 N Trc_pool_new_NoVerifyWithHolesExit " <pool_new POOL_VERIFY_FREE_LIST unsupported when POOL_USES_HOLES"
pool.64 4 1 1 N Trc_pool_verify_ExitPrevPuddleMismatch " <pool_verify failed pool %p puddle %p prev puddle not %p avail %d"
j9thr.0 0 1 1 N Trc_THR_VMInitStages_Event1 "  Trace engine initialized for module j9thr"
j9thr.1 0 1 3 N Trc_THR_Adapt_DisableSpinning "  Adapt: disabling spinning for %s monitor 0x%p based on avg holdtime (%llu / %zu) = %llu, slow percent (%zu / %zu) = %zu"
j9thr.2 0 1 3 N Trc_THR_Adapt_EnableSpinning "  Adapt: enabling spinning for %s monitor 0x%p based on avg holdtime (%llu / %zu) = %llu, slow percent (%zu / %zu) = %zu"
j9thr.3 0 1 3 N Trc_THR_Adapt_StopSampling "  Adapt: sampling stopped for %s monitor 0x%p based on avg holdtime (%llu / %zu) = %llu, slow percent (%zu / %zu) = %zu"
j9thr.4 0 1 3 N Trc_THR_Adapt_StartSampling "  Adapt: sampling started for %s monitor 0x%p"
j9thr.5 12 1 1 N Assert_THR_true "* ** ASSERTION FAILED ** at %s:%d: %s"
j9thr.6 2 1 3 N Trc_THR_ThreadSuspendEnter " >Thread suspended, thread=0x%p"
j9thr.7 4 1 3 N Trc_THR_ThreadSuspendExit " <Thread resumed from suspend, thread=0x%p"
j9thr.8 0 1 3 N Trc_THR_ThreadResumed "  Thread resumed by another thread, target thread=0x%p, calling thread=0x%p"
j9thr.9 2 1 3 N Trc_THR_ThreadMonitorNotifyEnter " >Thread notifying monitor, thread=0x%p, monitor=0x%p, notifyAll=%d"
j9thr.10 0 1 3 N Trc_THR_ThreadMonitorNotifyThreadNotified "  Thread notifying monitor, notifying thread=0x%p, target thread=0x%p, monitor=0x%p"
j9thr.11 4 1 3 N Trc_THR_ThreadMonitorNotifyExit " <Thread notifying monitor complete, thread=0x%p, monitor=0x%p, returnCode=%zd"
j9thr.12 2 1 3 N Trc_THR_ThreadInterruptEnter " >Thread interrupting another thread, interrupting thread=0x%p, interrupted thread=0x%p"
j9thr.13 4 1 3 N Trc_THR_ThreadInterruptExit " <Thread interrupt done, interrupted thread=0x%p"
j9thr.14 0 1 3 N Trc_THR_ThreadSetName "  Thread name set, thread=0x%p, name=%s"
j9thr.15 0 1 3 N Trc_THR_ThreadSetPriority "  Thread priority set, thread=0x%p, priority=%zu"
j9thr.16 0 1 3 N Trc_THR_ThreadNUMAAffinitySet "  Thread affinity set, thread=0x%p, nodeNumber=%zu"
j9thr.17 0 1 3 N Trc_THR_ThreadSpinLockThreadUnblocked "  Spinlock thread unblocked, unblocked thread=0x%p, target thread=0x%p, monitor=0x%p"
j9thr.18 1 1 1 N Trc_THR_ThreadGetCpuTime_Bpxgth "* BPXGTH call failed for thread=0x%p, ret_val=%d, ret_code=%d, reason_code=%d"
j9thr.19 1 1 1 N Trc_THR_ThreadGetCpuTime_BpxgthData "* BPXGTH did not populate data for thread=0x%p, ret_val=%d, limitc=%d"
j9thr.20 1 1 1 N Trc_THR_ThreadGetCpuTime_BpxgthBuffer "* BPXGTH Buffer Overrun for thread=0x%p, ret_val=%d, data_offset=%d, lenused=%d, output_size=%d"
j9thr.21 1 1 1 N Trc_THR_ThreadGetCpuTime_BpxgthEye "* BPXGTH pgthj eyecatcher missing for thread=0x%p, ret_val=%d"
j9thr.22 1 1 1 N Trc_THR_ThreadGetProcessTimes_GetProcessTimesFailed "* GetProcessTimes failed obtaining process times: error=%d"
j9thr.23 1 1 1 N Trc_THR_ThreadGetProcessTimes_getrusageFailed "* getrusage failed obtaining process times: error=%d"
j9thr.24 1 1 1 N Trc_THR_ThreadGetProcessTimes_bpxNgthFailed "* BPXNGTH failed obtaining process times: return_code=%d, reason_code=%d"
j9thr.25 1 1 1 N Trc_THR_omrthread_get_jvm_cpu_usage_info_get_cpu_time_failed "* omrthread_get_cpu_time failed for thread=0x%p, threadCpuTime=%lld"
j9thr.26 1 1 1 N Trc_THR_omrthread_get_jvm_cpu_usage_thread_walk_failed "* thread walk failed with ret=%d"
j9thr.27 1 1 1 N Trc_THR_omrthread_get_jvm_cpu_usage_timestamp_failed "* timestamp incorrect, preTimestamp=%llu, postTimestamp=%llu"
j9thr.28 1 1 1 N Trc_THR_omrthread_set_category_invalid_category "* Invalid thread category=%d for thread=0x%p"
j9thr.29 1 1 1 N Trc_THR_fixupThreadAccounting_omrthread_get_cpu_time_ex_failed "* omrthread_get_cpu_time_ex returned error=%lld for thread=0x%p"
j9thr.30 1 1 1 N Trc_THR_omrthread_get_cpu_time_ex_nullOSHandle "* omrthread_get_handle returned null for thread=0x%p"
j9thr.31 1 1 1 N Trc_THR_omrthread_get_cpu_time_ex_GetThreadTimes_failed "* GetThreadTimes returned error=%d for thread=0x%p"
j9thr.32 1 1 1 N Trc_THR_omrthread_get_cpu_time_ex_pthread_getrusage_np_failed "* pthread_getrusage_np returned error=%d for thread=0x%p"
j9thr.33 1 1 1 N Trc_THR_omrthread_get_cpu_time_ex_pthread_getcpuclockid_failed "* pthread_getcpuclockid returned error=%d for thread=0x%p"
j9thr.34 1 1 1 N Trc_THR_omrthread_get_jvm_cpu_usage_info_get_cpu_time_ex_failed "* omrthread_get_cpu_time_ex failed for thread=0x%p, result=%zd"
j9thr.35 1 1 1 N Trc_THR_omrthread_get_cpu_time_ex_clock_gettime_failed "* clock_gettime failed for clock_id=%d with error=%zd for thread=0x%p"
j9thr.36 1 1 1 N Trc_THR_fixupThreadAccounting_omrthread_get_cpu_time_ex_error "* omrthread_get_cpu_time_ex returned error=%zd for thread=0x%p"
j9thr.37 0 1 3 N Trc_THR_EnableRawMonitorSpin_CustomSpinOption "  (ENABLE_RAW_MONITOR_SPIN) Using custom spin counts: %s, monitor: %p, threeTierSpinCount1: %zu, threeTierSpinCount2: %zu, threeTierSpinCount3: %zu, adaptSpin: %zu"
